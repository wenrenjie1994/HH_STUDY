**Set集合笔记**  

----------


**一、HashSet集合介绍**  
1.java.util.Set接口 extends Collection接口  
2.Set接口的特点：  

    a.不允许存储重复的元素
    b.没有索引，没有带索引的方法，也不能使用普通的for循环遍历

3.java.util.HashSet集合 implements Set接口  

    HashSet的特点：  
    a.不允许存储重复的元素
    b.没有索引，没有带索引的方法，也不能使用普通的for循环遍历
    c.是一个无序的集合，存储元素和取出元素的顺序有可能不一致
    d.底层是一个哈希表结构（查询的速度非常的快）

4.Set集合只有两种遍历方式：迭代器和增强for循环  

**二、哈希值**  
1.哈希值：是一个十进制的整数，由系统随机给出（就是对象的地址值，是一个逻辑地址，是模拟出来的地址，不是数据实际存储的物理地址）  
Object类有一个方法可以获取对象的哈希值：int hashCode()返回对象的哈希码值  
hashCode()方法的源码：public native int hashCode();  
native代表该方法调用的是本地操作系统的方法  
2.String类的哈希值：重写了hashCode()方法  

**三、HashSet集合存储数据的结构（哈希表结构）**  
jdk 1.8版本之前：哈希表 = 数组 + 链表  
jdk 1.8版本之后：哈希表 = 数组 + 链表；哈希表 = 数组 + 红黑树（提高查询的速度）  

1.哈希表的特点：速度快  
2.哈希表的原理：数组用来存放哈希值，计算要存储元素的哈希值，并把该元素放在数组中对应哈希值的位置 -> 若有多个元素的哈希值是相同的，则产生了哈希冲突，这时用链表来将这些相同哈希值的元素连接起来，从而解决了哈希冲突 -> 若链表长度超过了8，则将链表转换为红黑树用来提高查询的速度  

**四、Set集合存储元素不重复的原理**  
1.前提：【存储的元素必须重写hashCode方法和equals方法】  
2.原理：  
Set集合在调用add方法的时候，add方法会调用元素的hashCode方法计算出该元素的哈希值；  
在集合中找有没有这个哈希值的元素，如果没有就会把这个元素存储到集合中；如果有，也就是发生了哈希冲突；  
这时调用equals方法和具有相同哈希值的元素进行比较，如果返回true，则不会把该元素存储到集合中；否则，就会把该元素存储到集合中  

**五、HashSet存储自定义类型元素**  
【必须要重写hashCode方法和equals方法】  

**六、LinkedHashSet集合**  
1.java.util.LinkedHashSet集合 extends HashSet集合  
2.LinkedHashSet集合的特点：底层是一个哈希表（数组 + 链表 + 红黑树） + 链表（记录元素的存储顺序，保证元素有序）  

**七、可变参数（jdk 1.5之后出现的新特性）**  
1.使用前提：当方法的参数列表数据类型已经确定，但是参数的个数不确定，就可以使用可变参数  
2.使用格式：定义方法时使用  

    修饰符 返回值类型 方法名(数据类型...数组变量名) {}

3.可变参数的原理：实现底层就是一个数组，根据传递参数的个数不同，会创建不同长度的数组，来存储这些参数；传递的参数个数可以是0、1、2、...  
4.注意事项：  
a.一个方法的参数列表只能有一个可变参数  
b.如果方法的参数有多个，那么可变参数必须写在参数列表的末尾  
5.可变参数的特殊（终极）写法：可以传递任意类型的可变参数  

    修饰符 返回值类型 方法名(Object...数组变量名) {}