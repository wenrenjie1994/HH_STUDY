**缓冲流笔记**  

----------


**一、缓冲流的原理**  

**二、BufferedOutputStream_字节缓冲输出流**  
java.io.BufferedOutputStream extends OutputStream  
继承自父类的共性成员方法：  
    
    1.public void close()：关闭此输出流并释放与此流相关联的任何系统资源
    
    2.public void flush()：属性此输出流并强制任何缓冲的数据字节被写出
    
    3.public void write(byte[] b)：将b.length字节从指定的字节数组写入此输出流
    
    4.public void write(byte[] b, int off, int len)：从指定的字节数组写入len字节，从偏移量off开始输出到此输出流
    
    5.public abstract void write(int b)：将指定的字节输出流

构造方法：  

    1.BufferedOutputStream(OutputStream out)：创建一个新的缓冲输出流，以将数据写入指定的底层输出流
    2.BufferedOutputStream(OutputStream out, int size)：创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流
    参数：
        OutputStream out：字节输出流（我们可以传递FileOutputStream，缓冲流会给FileOutputStream增加一个缓冲区，提高FileOutputStream的写入效率）
        int size：指定缓冲流内部缓冲区的大小，不指定默认

使用步骤【重点】：  
1.创建一个FileOutputStream对象，构造方法中绑定要输出的目的地  
2.创建BufferedOutputStream对象，构造方法中传递FileOutputStream对象  
3.使用BufferedOutputStream对象中的方法write，把数据写入到内部缓冲区中  
4.使用BufferedOutputStream对象中的方法flush，把内部缓冲区中的数据，刷新到文件中   
5.释放资源（会先调用flush方法刷新数据，第4步可以省略）  

**三、BufferedInputStream_字节缓冲输入流**  
java.io.BufferedInputStream extends InputStream  
继承自父类的共性成员方法：  

    1.int read()：从输入流中读取数据的下一个字节
    
    2.int read(byte[] b)：从输入流中读取一定数量的字节，并将其存储在缓冲区数组b中
    
    3.void close()：关闭此输入流并释放与该流关联的所有系统资源

构造方法：  

    1.BufferedInputStream(InputStream in)：创建一个新的缓冲输入流，以从指定的底层输入流读取数据
    2.BufferedInputStream(InputStream in, int size)：创建一个新的缓冲输入流，以从指定的底层输入流读取具有指定缓冲区大小的数据
    参数：
        InputStream in：字节输入流（我们可以传递FileInputStream，缓冲流会给FileInputStream增加一个缓冲区，提高FileInputStream的读取效率）
        int size：指定缓冲流内部缓冲区的大小，不指定默认

使用步骤【重点】：  
1.创建一个FileInputStream对象，构造方法中绑定要读取的数据源  
2.创建BufferedInputStream对象，构造方法中传递FileInputStream对象  
3.使用BufferedInputStream对象中的方法read，读取文件  
4.释放资源  

**四、缓冲流的效率测试_复制文件**  

```java
package bufferStream;

import java.io.*;

public class BufferedCopyImg {
    public static void main(String[] args) {
        FileInputStream fis = null;
        FileOutputStream fos = null;
        BufferedOutputStream bos = null;
        BufferedInputStream bis = null;
        try {
            fis = new FileInputStream(new File("E:\\IdeaProjects\\basic-code\\day0814-code\\src\\bufferStream\\image1.jpg"));
            bis = new BufferedInputStream(fis);
            fos = new FileOutputStream(new File("E:\\IdeaProjects\\basic-code\\day0814-code\\src\\bufferStream\\image2.jpg"));
            bos = new BufferedOutputStream(fos);
            byte[] bytes = new byte[1024];
            int len = 0;
            while ((len = bis.read(bytes)) != -1) {
                bos.write(bytes, 0, len);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (bos != null) {
                    bos.close();
                }
                if (bis != null) {
                    bis.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

**五、BufferedWriter_字符缓冲输出流**  
java.io.BufferedWriter extends Writer  
继承自父类的共性成员方法：  

    1.void write(int c)：写入单个字符  
    
    2.void write(char[] cbuf)：写入字符数组
    
    3.abstract void write(char[] cbuf, int off, int len)：写入字符数组的某一部分；off--数组的开始索引，len--写的字符个数
    
    4.void write(String str)：写入字符串
    
    5.void write(String str, int off, int len)：写入字符串的某一部分；off--字符串的开始索引，len--写的字符个数
    
    6.void flush()：刷新该流的缓冲
    
    7.void close()：关闭此流，但要先刷新它

构造方法：  

    1.BufferedWriter(Writer out)：创建一个使用默认大小输出缓冲区的缓冲字符输出流
    2.BufferedWriter(Writer out, int size)：创建一个使用给定大小输出缓冲区的缓冲字符输出流
    参数：
        Writer out：字符输出流（我们可以传递FileWriter，缓冲流会给FileWriter增加一个缓冲区，提高FileWriter的写入效率）
        int size：指定缓冲流内部缓冲区的大小，不指定默认

特有的成员方法：  
void newLine()：写入一个行分隔符；会根据不同的操作系统，获取不同的行分隔符  

使用步骤【重点】：  
1.创建一个FileWriter对象，构造方法中绑定要输出的目的地  
2.创建BufferedWriter对象，构造方法中传递FileWriter对象  
3.使用BufferedWriter对象中的方法write，把数据写入到内存缓冲区中  
4.使用BufferedWriter对象中的方法flush，把内存缓冲区中的数据，刷新到文件中  
5.释放资源  

**六、BufferedReader_字符缓冲输入流**  
java.io.BufferedReader extends Reader  
继承自父类的共性成员方法：  

    1.int read()：读取单个字符并返回字符个数
    
    2.int read(char[] cubf)：一次读取多个字符，将字符读入数组
    
    3.void close()：关闭并释放与之关联的所有资源

构造方法：  

    1.BufferedReader(Reader in)：创建一个使用默认大小输入缓冲区的缓冲字符输入流
    2.BufferedReader(Reader in, int size)：创建一个使用指定大小输入缓冲区的缓冲字符输入流
    参数：
        Reader in：字节输入流（我们可以传递FileReader，缓冲流会给FileReader增加一个缓冲区，提高FileReader的读取效率）
        int size：指定缓冲流内部缓冲区的大小，不指定默认

特有的成员方法：  
String readLine()：读取一个文本行，读取一行数据  
行的终止符号：'\r','\n','\r\n'  
返回值：包含该内容的字符串，不包含任何终止符，如果已达到流末尾则返回null  

使用步骤【重点】：  
1.创建一个FileReader对象，构造方法中绑定要读取的数据源  
2.创建BufferedReader对象，构造方法中传递FileReader对象  
3.使用BufferedReader对象中的方法read/readLine，读取文件  
4.释放资源  

**七、练习_对文本的内容进行排序**  

```java
package bufferStream;

import java.io.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Set;

public class TxtSort {
    public static void main(String[] args) {
        BufferedWriter bw = null;
        BufferedReader br = null;
        try {
            br = new BufferedReader(new FileReader(new File("E:\\IdeaProjects\\basic-code\\day0814-code\\src\\bufferStream\\a.txt")));
            bw = new BufferedWriter(new FileWriter(new File("E:\\IdeaProjects\\basic-code\\day0814-code\\src\\bufferStream\\b.txt")));
            HashMap<Integer, String> map = new HashMap<>();
            //1.从a.txt读取数据并存储到Map集合中
            String s = null;
            while ((s = br.readLine()) != null) {
                map.put((int) s.charAt(0), s);
                //Map集合会自动排序
            }
            //2.将排好序的文本写入到b.txt文件中
            for (Integer key : map.keySet()) {
                bw.write(map.get(key));
                bw.newLine();
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (bw != null) {
                    bw.close();
                }
                if (br != null) {
                    br.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```