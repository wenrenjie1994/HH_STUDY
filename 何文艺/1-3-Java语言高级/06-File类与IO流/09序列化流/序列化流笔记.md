**序列化流笔记**  

----------


**一、序列化和反序列化的概述**  
把对象以流的方式写入到文件中保存，叫写对象，也叫对象的序列化  
对象中包含的不仅仅是字符，所以要使用字节流  
ObjectOutputStream：对象的序列化流  

把文件中保存的对象以流的方式读取出来，叫读对象，也叫对象的反序列化  
读取的文件保存的都是字节，所以要使用字节流  
ObjectInputStream：对象的反序列化流  

**二、对象的序列化流_ObjectOutputStream**  
java.io.ObjectOutputStream extends OutputStream  
作用：把对象以流的方式写入到文件中保存  
构造方法：  

    ObjectOutputStream(OutputStream out)：创建写入指定OutputStream的ObjectOutputStream
    参数：
        OutputStream out：字节输出流

特有的成员方法：  
void writeObject(Object obj)：将指定的对象写入ObjectOutputStream  

使用步骤：  
1.创建一个ObjectOutputStream对象，构造方法中传递OutputStream对象  
2.使用ObjectOutputStream对象中的方法write，把对象写入到文件中  
3.释放资源  

序列化和反序列化的时候会抛出NotSerializableException没有序列化异常  
类通过实现java.io.Serializable接口以启用其序列化功能，未实现此接口的类将无法使其任何状态序列化或反序列化NotSerializableException异常  
Serializable接口也叫标记型接口  
要进行序列化和反序列化的类必须实现Serializable接口，就会给类添加一个标记  
当我们进行序列化和反序列化的时候就会检测类上是否有这个标记，如果有就可以进行序列化和反序列化，如果没有就会抛出  

**三、对象的反序列化流_ObjectInputStream**  
java.io.ObjectInputStream extends InputStream  
作用：把文件中保存的对象以流的方式读取出来  
构造方法：  

    ObjectInputStream(InputStream in)：创建从指定InputStream读取的ObjectInputStream
    参数：
        InputStream in：字节输入流

特有的成员方法：  
Object readObject()：从ObjectInputStream读取对象  
这个方法声明抛出了ClassNotFoundException（class文件找不到异常），当不存在对象的class文件时抛出异常  
反序列化的前提：  
1.类必须实现Serializable接口  
2.必须存在类对应的class文件  

使用步骤：  
1.创建一个ObjectInputStream对象，构造方法中传递InputStream对象  
2.使用ObjectInputStream对象中的方法read，读取保存对象的文件  
3.释放资源  
4.使用读取出来的对象  

**四、transient关键字_瞬态关键字**  
1.static关键字：静态关键字  
静态优先于非静态加载到内存中（静态优先于对象进入到内存中）  
被static修饰的成员变量不能被序列化的，因为序列化的都是对象（而静态变量不属于对象，被所有对象共享）  
2.transient关键字：瞬态关键字  
被transient修饰的成员变量不能被序列化  

**五、InvalidClassException异常_原理\***  
static final long serialVersionUID = 序列号  

**六、练习_序列化集合**  
要求：  
1.将存有多个自定义对象的集合序列化操作，保存到list.txt文件中  
2.反序列化list.txt，并遍历集合，打印对象信息  

Person.java  

```java
package serialize;

import java.io.Serializable;

public class Person implements Serializable {
    private static final long serialVersionUID = 10L;//解决InvalidClassException异常
    private String name;
    public int age;

    //此处省略有参和无参构造方法、Getter和Setter、toString方法
}
```

SerializePerson.java  

```java
package serialize;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.util.ArrayList;

public class SerializePerson {
    public static void main(String[] args) {
        ArrayList<Person> list = new ArrayList<>();
        list.add(new Person("张三", 18));
        list.add(new Person("李四", 19));
        list.add(new Person("王五", 25));
        ObjectOutputStream oos = null;
        try {
            oos = new ObjectOutputStream(new FileOutputStream("E:\\IdeaProjects\\basic-code\\day0814-code\\src\\serialize\\list.txt"));
            oos.writeObject(list);
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (oos != null) {
                    oos.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

DeserializePerson.java  

```java
package serialize;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectInputStream;
import java.util.ArrayList;

public class DeserializePerson {
    public static void main(String[] args) {
        ObjectInputStream ois = null;
        try {
            ois = new ObjectInputStream(new FileInputStream("E:\\IdeaProjects\\basic-code\\day0814-code\\src\\serialize\\list.txt"));
            ArrayList<Person> list = (ArrayList<Person>)ois.readObject();
            for (Person person : list) {
                System.out.println(person.toString());
            }
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }finally {
            try {
                if (ois != null) {
                    ois.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}

```