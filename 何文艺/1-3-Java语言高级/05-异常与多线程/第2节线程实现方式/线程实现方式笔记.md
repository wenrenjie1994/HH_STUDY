**线程实现方式笔记**  

----------

**一、并发与并行**  
1.并发：指两个或多个事件在【同一个时间段内】发生（交替执行）  
2.并行：指两个或多个事件在【同一时刻】发生（同时执行）  

**二、进程概念**  
进程：进入到内存的程序叫进程  
任务管理器（里面的一个任务就是一个进程）-->结束任务，就把进程从内存中清除了  

**三、线程概念**  
1.CPU：中央处理器；对数据进行计算，指挥电脑中的软硬件干活  
&nbsp;&nbsp;&nbsp;CPU的分类：AMD/Inter  
2.线程：属于进程，是进程中的一个执行单元，负责程序的执行  
&nbsp;&nbsp;&nbsp;3.多线程的好处：  
&nbsp;&nbsp;&nbsp;a.效率高  
&nbsp;&nbsp;&nbsp;b.多个线程之间互不影响  

**四、线程调度**  
1.分时调度：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间  
2.抢占式调度：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个（线程随机性），【java使用的为抢占式调度】  

**五、主线程**  
1.主线程：执行主方法（main方法）的线程  
2.单线程程序：java程序中只有一个线程  
执行从main方法开始，从上到下依次执行  

**六、创建多线程程序的第一种方式_创建Thread类的子类**  
1.java.lang.Thread类：是描述线程的类，我们想要实现多线程程序，就必须继承Thread类  
2.实现步骤：  
&nbsp;&nbsp;&nbsp;a.创建一个Thread类的子类  
&nbsp;&nbsp;&nbsp;b.在Thread类的子类中重写Thread类中的run方法，设置线程任务（也就是线程要做什么）  
&nbsp;&nbsp;&nbsp;c.创建Thread类的子类对象  
&nbsp;&nbsp;&nbsp;d.调用Thread类中的start()方法，开启新的线程，执行run方法  

MyThread.java

```java
package thread;
//1.创建一个Thread类的子类
public class MyThread extends Thread{
    //2.在Thread类的子类中重写Thread类中的run方法，设置线程任务（也就是线程要做什么）
    @Override
    public void run() {
        //线程任务
    }
}
```

Demo01.java

```java
package thread;

public class Demo01 {
    public static void main(String[] args) {
    	//3.创建Thread类的子类对象
        MyThread myThread = new MyThread();
        //4.调用Thread类中的start()方法，开启新的线程，执行run方法
        myThread.start();
    }
}
```

注意：  
void start()使该线程开始执行：java虚拟机调用该线程的run方法  
结果是两个线程并发地运行；当前线程（main线程）和另一个线程（创建的新线程，执行其run方法）  
多次启动一个线程是非法的；特别是当线程已经结束执行后，不能再重新启动  

**七、多线程原理_随机性打印结果\***  

**八、多线程原理_多线程内存图解\***  
每创建一个新的线程，内存中就会开辟一个新的栈空间  
因此多线程的好处就是：多个线程之间互不影响（在不同的栈空间）  

**九、Thread类的常用方法_获取线程名称**  
1.线程的名称：  
&nbsp;&nbsp;&nbsp;主线程：main  
&nbsp;&nbsp;&nbsp;新线程：Thread-0、Thread-1、Thread-2、...  
2.获取线程名称的2种方法：  

    a.使用Thread类中的方法：String getName()  
      getName()  
    b.先获取到当前正在执行的线程：static Thread currentThread()，再使用线程中的getName()方法获取线程的名称  
      Thread.currentThread().getName()  

获取主线程的名称只能使用第二种方式，因为main方法所在的类并未继承Thread类    

**十、Thread类的常用方法_设置线程名称（了解）**  
1.使用Thread类中的方法void setName(String name)  
2.创建一个带参数的构造方法，参数传递线程的名称；调用父类的带参构造方法，把线程名称传递给父类，让父类（Thread）给子线程起一个名字Thread(String name)  

**十一、Thread类的常用方法_sleep**  
public static void sleep(long millisecond)：使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）  
毫秒数结束之后，线程继续执行  

**十二、创建多线程程序的第二种方式_实现Runnable接口的方式**  
java.lang.Runnable：Runnable接口应该由那些打算通过某一线程执行其实例的类来实现，类必须定义一个称为run的无参数方法  
java.lang.Thread类的构造方法：Thread(Runnable target)、Thread(Runnable target, String name)分配新的Thread对象  
实现步骤：  
&nbsp;&nbsp;&nbsp;1.创建一个Runnable接口的实现类  
&nbsp;&nbsp;&nbsp;2.在实现类中重写Runnable接口的run方法，设置线程任务  
&nbsp;&nbsp;&nbsp;3.创建一个Runnable接口的实现类对象  
&nbsp;&nbsp;&nbsp;4.创建Thread类对象，构造方法中传递Runnable接口的实现类对象  
&nbsp;&nbsp;&nbsp;5.调用Thread类中的start方法，开启新的线程，执行run方法  

RunnableImpl.java  

```java
package thread;

//1.创建一个Runnable接口的实现类
public class RunnableImpl implements Runnable {
    @Override
    //2.在实现类中重写Runnable接口的run方法，设置线程任务
    public void run() {
        //线程任务
    }
}
```

Demo02.java

```java
package thread;

public class Demo02{
    public static void main(String[] args) {
        //3.创建一个Runnable接口的实现类对象
        RunnableImpl runnable = new RunnableImpl();
        //4.创建Thread类对象，构造方法中传递Runnable接口的实现类对象
        Thread thread = new Thread(runnable);
        //5.调用Thread类中的start方法，开启新的线程，执行run方法
        thread.start();
    }
}
```

**十三、Thread和Runnable方式的区别**
实现Runnable接口创建多线程程序的好处：  
1.避免了单继承的局限性：一个类只能继承一个类（一个人只能有一个亲爹），类继承了Thread类，就不能再继承其他的类；但实现了Runnable接口，还可以继承其他的类，实现其他的接口  
2.增强了程序的扩展性，降低了程序的耦合性（解耦）：实现Runnable接口的方式，把设置线程任务和开启新线程进行了分离（解耦）；实现类中，重写了run方法，用来设置线程任务；而创建Thread类对象，调用start方法，用来开启新线程  

**十四、匿名内部类方式实现线程的创建**  
匿名：没有名字  
内部类：写在其他类内部的类  

匿名内部类作用：简化代码  
把子类继承父类，重写父类的方法，创建子类对象合成一步完成  
把实现类实现接口，重写接口中的方法，创建实现类对象合成一步完成  
匿名内部类的最终产物：子类/实现类对象，而这个类没有名字  

格式：  

    new 父类/接口() {
        重写父类/接口中的方法
    }

InnerClassThread.java  

```java
package thread;

public class InnerClassThread {
    public static void main(String[] args) {
        new Thread(){
            @Override
            public void run() {
                //重写run方法，设置任务
            }
        }.start();

         new Thread(new RunnableImpl() {
            @Override
            public void run() {
                //重写run方法，设置任务
            }
        }).start();
    }
}
```