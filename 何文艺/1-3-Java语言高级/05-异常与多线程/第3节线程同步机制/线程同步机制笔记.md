**线程同步机制笔记**  

----------


**一、线程安全问题的概述**  
多线程访问了【共享的】数据，会产生线程安全问题  

**二、线程安全问题的代码实现**  

**三、线程安全问题产生的原理\***  

**四、解决线程安全问题_同步代码块**  
线程安全问题的解决方案：  
1.同步代码块  
2.同步方法  
3.lock锁  

1.同步代码块格式：  

```java
synchronized(锁对象) {
    可能会出现线程安全问题的代码（访问了共享数据的代码）
}
```

2.注意：  
a.同步代码块中的锁对象可以是任意的对象  
b.但是必须保证多个线程使用的锁对象是同一个  
c.锁对象的作用：把同步代码块锁住，只让一个线程在同步代码块中执行  

RunnableImple.java  

```java
package ThreadSafety;
  
public class RunnableImple implements Runnable{
    //创建共享资源（票一共只有100张）
    private int ticket = 100;

    //创建锁对象（锁对象只有一个）
    Object object = new Object();

    //设置线程任务：卖票
    @Override
    public void run() {
        while (true) {
            synchronized (object) {
                //同步代码块
                if (ticket > 0) {
                    System.out.println(Thread.currentThread().getName() + "正在买卖第" + ticket + "张票");
                    ticket--;
                }
            }
        }
    }
}
```

SellTicket.java  

```java
package ThreadSafety;

public class SellTicket {
    public static void main(String[] args) {
         //为了实现资源共享只创建一个RunnableImple对象，让所有的线程都去卖那100张票
        RunnableImple runnable = new RunnableImple();
        Thread thread0 = new Thread(runnable);
        Thread thread1 = new Thread(runnable);
        Thread thread2 = new Thread(runnable);
        thread0.start();
        thread1.start();
        thread2.start();
    }
}
```

**五、同步技术的原理\***  
使用了一个锁对象，这个锁对象叫同步锁，也叫对象锁，也叫对象监视器  
同步中（synchronized代码块）的线程没有执行完毕不会释放锁，同步外的线程没有锁进不去同步  
同步保证了只能有一个线程在同步中执行共享数据，从而保证了程序的安全性；但程序频繁的判断锁，获取锁，释放锁，程序的效率会降低   

**六、解决线程安全问题_同步方法**  
1.使用步骤：  
a.把访问了共享数据的代码抽取出来，放到一个方法中  
b.在方法上添加synchronized修饰符  
2.定义方法的格式：  

```java
修饰符 synchronized 返回值类型 方法名(参数列表) {
    可能会出现线程安全问题的代码（访问了共享数据的代码）
}
```

RunnableImple.java  

```java
package ThreadSafety;

public class RunnableImple implements Runnable{
    //创建共享资源（票一共只有100张）
    private int ticket = 100;

    //设置线程任务：卖票
    @Override
    public void run() {
        while (true) {
            sellTicket();
        }
    }

    public synchronized void sellTicket() {
        //同步代码块
        if (ticket > 0) {
            System.out.println(Thread.currentThread().getName() + "正在买卖第" + ticket + "张票");
            ticket--;
        }
    }
}
```

3.同步方法的原理：同步方法也会把方法内部的代码锁住，只让一个线程执行，同步方法的锁对象就是实现类对象new RunnableImple()，也就是this  

**七、静态同步方法**  
RunnableImple.java  
    
```java
package ThreadSafety;

public class RunnableImple implements Runnable{
    //创建共享资源（票一种只有100张）
    private static int ticket = 100;

    //设置线程任务：卖票
    @Override
    public void run() {
        while (true) {
            sellTicket();
        }
    }

    public static synchronized void sellTicket() {
        //同步代码块
        if (ticket > 0) {
            System.out.println(Thread.currentThread().getName() + "正在买卖第" + ticket + "张票");
            ticket--;
        }
    }
}
```

静态同步方法的锁对象：不再是this，因为this是创建对象之后产生的，而静态方法优先于对象；因此静态方法的锁对象是本类的class属性，也就是class文件对象（反射）  
RunnableImple.java  
    
```java
package ThreadSafety;

public class RunnableImple implements Runnable{
    //创建共享资源（票一种只有100张）
    private static int ticket = 100;

    //设置线程任务：卖票
    @Override
    public void run() {
        while (true) {
            sellTicket();
        }
    }

    public static void sellTicket() {
        synchronized (RunnableImpl.class) {
        //同步代码块
        if (ticket > 0) {
            System.out.println(Thread.currentThread().getName() + "正在买卖第" + ticket + "张票");
            ticket--;
        }
    }
    }
}
```

**八、解决线程安全问题_lock锁**  
java.util.concurrent.locks.lock接口  
lock实现提供了比使用synchronized()方法和语句可获得的更广泛的锁定操作  
1.lock接口中的方法：  
&nbsp;&nbsp;&nbsp;void lock()获取锁  
&nbsp;&nbsp;&nbsp;void unlock()释放锁  
2.使用步骤：  
&nbsp;&nbsp;&nbsp;a.在成员位置创建一个ReentrantLock对象  
&nbsp;&nbsp;&nbsp;b.在可能会出现安全问题的代码前调用lock接口中的方法lock()获取锁  
&nbsp;&nbsp;&nbsp;c.在可能会出现安全问题的代码后调用lock接口中的方法unlock()释放锁  

RunnableImple.java  

```java
package ThreadSafety;

import thread.RunnableImpl;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class RunnableImple implements Runnable{
    //创建共享资源（票一共只有100张）
    private static int ticket = 100;
    //在成员位置创建一个ReentrantLock对象
    Lock lock = new ReentrantLock();

    //设置线程任务：卖票
    @Override
    public void run() {
        while (true) {
            //在可能会出现安全问题的代码前调用lock接口中的方法lock()获取锁
            lock.lock();
            try {
                if (ticket > 0) {
                    System.out.println(Thread.currentThread().getName() + "正在买卖第" + ticket + "张票");
                    ticket--;
                }
            } finally {//无论代码是否有异常，都要将锁释放掉
                //在可能会出现安全问题的代码后调用lock接口中的方法unlock()释放锁
                lock.unlock();
            }
        }
    }
}
```