**异常笔记**  

----------

**一、异常概念&异常体系**  
1.异常：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止  
在java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象；java处理异常的方式是【中断处理】  
异常指的并不是语法错误，语法错了，编译不通过，不会产生字节码文件，根本就不能运行  
2.异常体系：异常机制其实是帮助我们找到程序中的问题   
异常的根类是java.lang.Throwable，其下有两个子类：java.lang.Error与java.lang.Exception；平常所说的异常指java.lang.Exception  
&nbsp;&nbsp;&nbsp;2.1 Error：严重错误，无法通过处理的错误，只能事先避免，好比绝症  
&nbsp;&nbsp;&nbsp;2.2 Exception：表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须处理的，好比感冒  

**二、异常分类**  
1.Exception：编译期异常，进行编译（写代码）java程序出现的问题【在IDEA中写代码的时候标红线就是编译期异常】  
&nbsp;&nbsp;&nbsp;RuntimeException（Exception的子类）：运行期异常，java程序运行过程中出现的问题【在IDEA中写代码的时候不报错，但运行时报错就是运行期异常】  
异常就相当于程序得了一个小毛病，把异常处理掉，程序可以继续执行（吃点药）  
2.Error：错误，就相当于程序得了一个无法治愈的毛病，必须修改源代码，程序才能继续执行  

**三、异常的产生过程解析\***  

**四、throw关键字**  
java异常处理的五个关键字：try、catch、finally、throw、throws  
1.throw关键字作用：可以使用throw关键字在指定的方法中抛出指定的异常  
2.throw关键字使用格式：  

```java
throw new xxxException("异常产生的原因");  
```

3.注意：  
&nbsp;&nbsp;&nbsp;a.throw关键字必须写在方法的内部  
&nbsp;&nbsp;&nbsp;b.throw关键字后边new的对象必须是Exception或者Exception的子类对象  
&nbsp;&nbsp;&nbsp;c.throw关键字抛出指定的异常对象，我们就必须处理这个异常对象  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw关键字后边创建的是RuntimeException或者是RuntimeException的子类对象，我们可以不处理，默认交给JVM处理（打印异常对象，中断程序）  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw关键字后边创建的是编译异常（写代码的时候报错），我们就必须处理这个异常，要么throws，要么try...catch  

以后（工作中）我们首先必须对方法传递过来的参数进行合法性校验  
如果参数不合法，那么我们就必须使用抛出异常的方式，告知方法的调用者传递的参数有问题  
注意：NullPointerException、IndexOutOfBoundsException都是运行期异常，我们不用处理，默认交给JVM处理  

**五、Objects非空判断_requireNonNull**  

    public static <T> T requireNonNull(T obj)：检查指定的对象引用不是 null（该方法主要用于在方法和构造函数中进行参数验证）  

**六、throws关键字_异常处理的第一种方式**  
throws关键字：异常处理的第一种方式，交给别人处理  
1.作用：当方法内部抛出异常对象的时候，那么我们就必须处理这个异常对象；可以使用throws关键字处理异常对象，会把异常对象声明抛出给方法的调用者处理（自己不处理，给别人处理，最终交给JVM处理-->中断处理）  
2.使用格式：在方法声明时使用  

```java
修饰符 返回值类型 方法名（参数列表） throws aaaException,bbbException...{
    throw new aaaException("产生原因");
    throw new bbbException("产生原因");
    ...
}
```

3.注意：  
&nbsp;&nbsp;&nbsp;a.throws关键字必须写在方法声明处  
&nbsp;&nbsp;&nbsp;b.throws关键字后边声明的异常必须是Exception或Exception的子类  
&nbsp;&nbsp;&nbsp;c.方法内部如果抛出了多个异常对象，那么throws后边必须也声明多个异常  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果抛出多个异常对象有子父类关系，那么直接声明父类异常即可  
&nbsp;&nbsp;&nbsp;d.调用了一个声明抛出异常的方法，我们就必须处理声明的异常：要么继续使用throws声明抛出，把异常交给方法的调用者处理，最终交给JVM；要么try...catch自己处理异常  

**七、try_catch_异常处理的第二种方式**  
try...catch：异常处理的第二种方式，自己处理异常  
1.格式：  

```java
try {
    可能产生异常的代码
} catch(定义一个异常变量，用来接受try中抛出的异常对象) {
    异常的处理逻辑（即产生异常对象之后，怎么处理异常对象）
    //一般在工作中，会把异常的信息记录到一个日志中
}
...
catch(异常类名 变量名) {
    异常的处理逻辑
}
```

2.注意：  
&nbsp;&nbsp;&nbsp;a.try中可能会抛出多个异常对象，那么就可以使用多个catch来处理这些异常对象  
&nbsp;&nbsp;&nbsp;b.如果try中产生了异常，那么就会执行catch中的异常处理逻辑，执行完毕catch中的处理逻辑，继续执行try...catch之后的代码  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果try中没有产生异常，那么就不会执行catch中的异常处理逻辑，执行完try中的代码，继续执行try...catch之后的代码  

**八、Throwable类中3个异常处理的方法**  
1.String getMessage()：返回此 Throwable 的简短描述  
2.String toString()：返回此 Throwable 的详细消息字符串  
3.void printStackTrace()：JVM打印异常对象默认调用此方法，打印的异常信息是最全面的  

**九、finally代码块**  
1.finally代码块：有一些特定的代码无论异常是否发生，都需要执行；另外，因为异常会引发程序跳转，导致有些语句执行不到；而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的  
2.使用格式：  

```java
try {
   可能产生异常的代码
} catch(定义一个异常变量，用来接受try中抛出的异常对象) {
    异常的处理逻辑（即产生异常对象之后，怎么处理异常对象）
    //一般在工作中，会把异常的信息记录到一个日志中
}
...
catch(异常类名 变量名) {
    异常的处理逻辑
} finally {
    无论是否出现异常都会执行
}
```

3.注意：  
a.finally不能单独使用，必须和try一起使用  
b.finally一般用于资源释放（资源回收），无论程序是否出现异常，最后都要资源释放（IO）  

**十、异常注意事项_多异常的捕获处理**  
多个异常的捕获处理  
1.多个异常分别处理  
2.多个异常一次捕获，多次处理：  
注意：catch里面定义的异常变量如果有子父类关系，那么子类的异常变量必须写在父类的前面，否则就会报错
（如果父类写在前面，则不论是子类还是父类异常都可以接收，后面的子类语句就无用了）  
3.多个异常一次捕获，一次处理：在catch中选择所有异常都可以接收的异常变量类型  

注意：运行时异常被抛出可以不处理，即不捕获也不声明抛出，默认交给虚拟机处理，终止程序，什么时候不抛出运行时异常了，再来继续执行程序  

**十一、异常注意事项_finally没-有return语句**  
如果finally有return语句，则永远返回finally中的结果，应该避免该情况发生（不要在finally代码块里面写return语句）  

**十二、异常注意事项_子父类异常**  
1.如果父类抛出了多个异常，子类重写父类方法时，应该抛出【和父类相同的异常】或者是【抛出父类异常的子类】或者是【不抛出异常】  
2.父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常；此时子类产生异常则只能捕获处理，不能声明抛出  
原则：子类和父类异常情况一样即可  

**十三、自定义异常类**  
1.自定义异常类：java提供的异常类不够我们开发使用，需要自己定义一些异常类  
2.格式：  

    public class xxxException extends Exception/RunTimeException {
        添加一个空参数的构造方法
        /*查看源码发现，所有的异常类都会有一个带异常信息的构造方法，方法内部会调用父类带异常信息的构造方法，让父类来处理这个异常信息*/
        添加一个带异常信息的构造方法
    }

3.注意：  
a.自定义异常类一般都是以Exception结尾，说明该类是一个异常类  
b.自定义异常类必须继承Exception（编译期）或者是RunTimeException（运行期）  
&nbsp;&nbsp;&nbsp;继承Exception：那么自定义的异常类就是一个编译期异常，如果方法内部抛出了编译期异常，就必须处理这个异常（throws/try...catch）  
&nbsp;&nbsp;&nbsp;继承RunTimeException：那么自定义的异常类就是一个运行期异常，无需处理，交给JVM处理（中断处理）  

**十四、自定义异常类的练习**  
1.编译期异常  
RegisterException.java  

```java
package exception;

/*
题目：模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册
*/
public class RegisterException extends Exception{
    public RegisterException() {
        super();
    }

    public RegisterException(String message) {
        super(message);
    }
}
```

Demo01RegisterException.java  

```java
package exception;

import java.util.Scanner;

/*public class Demo01RegisterException {//throws
    private static String[] register = {"tom","lucy","maggie"};
    public static void main(String[] args) throws RegisterException {
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入您的用户名：");
        String username = scanner.nextLine();
        checkUsername(username);
    }
    public static void checkUsername(String username) throws RegisterException {
        for (int i = 0; i < register.length; i++) {
            if (register[i].equals(username)) {
                    throw new RegisterException("亲，该用户名已经被注册");
            }
        }
        System.out.println("注册成功！");
    }
}*/

public class Demo01RegisterException {//try...catch
    private static String[] register = {"tom", "lucy", "maggie"};

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入您的用户名：");
        String username = scanner.nextLine();
        checkUsername(username);
    }

    public static void checkUsername(String username) {
        for (int i = 0; i < register.length; i++) {
            if (register[i].equals(username)) {
                try {
                    throw new RegisterException("亲，该用户名已经被注册");
                } catch (RegisterException e) {
                    e.printStackTrace();
                    return;//否则System.out.println("注册成功！");还会执行
                }
            }
        }
        System.out.println("注册成功！");
    }
}
```

2.运行期异常  
RegisterException.java  

```java
package exception;

/*
题目：模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册
*/
public class RegisterException extends RuntimeException{
    public RegisterException() {
        super();
    }

    public RegisterException(String message) {
        super(message);
    }
}
```

Demo01RegisterException.java  

```java
package exception;

import java.util.Scanner;

public class Demo01RegisterException {
    private static String[] register = {"tom", "lucy", "maggie"};

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入您的用户名：");
        String username = scanner.nextLine();
        checkUsername(username);
    }

    public static void checkUsername(String username) {
        for (int i = 0; i < register.length; i++) {
            if (register[i].equals(username)) {
                throw new RegisterException("亲，该用户名已经被注册");
            }
        }
        System.out.println("注册成功！");
    }
}
```
