**等待唤醒机制笔记**  

----------


**一、线程状态概述**  
NEW（新建）：尚未启动的线程处于此状态  
线程刚被创建，但是并未启动，还没调用start方法  

RUNNABLE（可运行）：在Java虚拟机中执行的线程处于此状态  
线程可以在java虚拟机中运行的状态，可能正在运行自己的代码，也可能没有，这取决于操作系统处理器  

BLOCKED（锁阻塞）：被阻塞等待监视器锁定的线程处于此状态  
当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入blocked状态；当该线程持有锁时，该线程将变成Runnable状态  

WAITING（无限等待）：正在等待另一个线程执行特定动作的线程处于此状态  
一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入waiting状态；进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能被唤醒  

TIMED_WAITING（计时等待）：正在等待另一个线程执行动作达到指定等待时间的线程处于此状态  
同waiting状态，有几个方法有超时参数，调用他们将进入timed   waiting状态；这一状态将一直保持到超时期满或者接收到唤醒通知；带有超时参数的常用方法有Thread.sleep、Object.wait  

TERMINATED：已退出的线程处于此状态  
因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡  

**二、等待唤醒案例分析**  
等待唤醒案例：线程之间的通信  
生产者与消费者  

**三、等待唤醒案例代码实现**  
消费者线程：告知生产者需要的产品的种类和数量，调用wait方法，放弃cpu的执行，进入到WAITING（无限等待）状态  
生产者线程：生产者花5s生产产品，然后调用notify方法，唤醒消费者  

【注意事项】：  
1.消费者和生产者线程必须使用同步代码块包裹起来，保证等待和唤醒只能有一个在执行  
2.同步使用的锁对象必须保证是唯一的  
3.只有锁对象才能调用wait和notify方法  

Object类中的方法  
1.void	wait()：导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法  
2.void	notify()：唤醒正在等待对象监视器的单个线程；会继续执行wait()方法之后的代码  
3.void	notifyAll()：唤醒正在等待对象监视器的所有线程  

Demo01WaitAndNotify.java  

```java
public class Demo01WaitAndNotify {
    public static void main(String[] args) {
        //创建锁对象，保证唯一
        Object object = new Object();
        new Thread() {
            @Override
            public void run() {
                while (true) {
                    //保证等待和唤醒的线程只能由一个执行，需要使用同步技术
                    synchronized (object) {
                        System.out.println("告知生产者需要的产品的种类和数量");
                        //调用wait方法，放弃cpu的执行，进入到WAITING（无限等待）状态
                        try {//此处不能throws声明的，因为父类run方法没有抛异常
                            object.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        //唤醒之后执行的代码
                        System.out.println("消费者开始消费产品了");
                        System.out.println("----------------");
                    }
                }
            }
        }.start();
        new Thread() {
            @Override
            public void run() {
                while (true) {
                    //生产者花5s生产产品
                    try {
                        Thread.sleep(5000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    synchronized (object) {
                        //然后调用notify方法，唤醒消费者
                        System.out.println("生产者5s之后生产好产品，告知消费者可以消费产品了");
                        object.notify();
                    }
                }
            }
        }.start();
    }
}
```

**四、Object类中wait带参方法和notifyAll方法**  
进入到TIMED_WAITING（计时等待）状态有两种方式：  
1.使用sleep(long 毫秒值)方法，在毫秒值结束之后，线程睡醒进入到Runnable/Blocked状态  
2.使用wait(long 毫秒值)方法，wait方法如果在毫秒值结束之后还没有被notify唤醒，就会自动醒来，进入到Runnable/Blocked状态  

唤醒的方法：  
1.void	notify()：唤醒正在等待对象监视器的单个线程；会继续执行wait()方法之后的代码  
2.void	notifyAll()：唤醒正在等待对象监视器的所有线程  

**五、线程间通信（等待唤醒机制）**  

**六、等待唤醒机制概述**  

**七、等待唤醒机制需求分析**  
需要的类：  
1.资源类：设置资源的属性，包括状态  

2.生产者类：是一个线程类，可以继承Thread；设置线程任务（生产资源）  
对资源的状态进行判断，如果是true则表示有资源，则生产者调用wait方法进入等待状态  
如果是false则表示没有资源，生产者生产资源-->生产者生产好了资源，就需要修改资源的状态为true，唤醒消费者消费资源  

3.消费者类：也是一个线程类，可以继承Thread；设置线程任务（消费资源）  
对资源的状态进行判断，如果是false则表示没有资源，则消费者调用wait方法进入等待状态  
如果是true则表示有资源，则消费者消费资源-->消费者消费完了资源，就需要修改资源的状态为false，唤醒生产者生产资源  

4.测试类：包含main方法，程序执行的入口  
创建资源-->创建生产者线程并开启-->创建消费者线程并开启  

**八、等待唤醒机制_资源类和生产者类**  
注意：  
1.生产者线程和消费者线程的关系-->通信（互斥）  
2.必须使用同步技术保证两个线程只能有一个在执行  
3.锁对象必须保证唯一，可以使用资源类对象作为锁对象  
4.生产者类和消费者类就需要把资源类对象作为参数传递进去  
&nbsp;&nbsp;&nbsp;a.需要在成员位置创建一个资源变量  
&nbsp;&nbsp;&nbsp;b.使用带参数的构造方法，为这个包子变量赋值  

**九、等待唤醒机制_消费者类和测试**  
1.资源类Resource.java  

```java
package waitwake;

/*
设置资源的属性，包括状态(以买卖包子为例,包子即为资源)
*/
public class Resource {
    //皮
    String pi;
    //馅
    String xian;
    //状态
    Boolean status = false;
}
```

2.生产者类Producer.java  

```java
package waitwake;

/*
生产者类：是一个线程类，可以继承Thread；设置线程任务（生产资源）
对资源的状态进行判断，如果是true则表示有资源，则生产者调用wait方法进入等待状态
如果是false则表示没有资源，生产者生产资源-->生产者生产好了资源，就需要修改资源的状态为true，唤醒消费者消费资源
*/
public class Producer extends Thread{
    //在成员位置创建一个包子变量
    private Resource resource;

    //用带参数的构造方法，为这个包子变量赋值
    public Producer(Resource resource) {
        this.resource = resource;
    }

    @Override
    public void run() {//生产包子
        //定义一个变量
        int count = 0;
        while (true) {//生产者一直生产包子
            //必须使用同步技术保证两个线程只能有一个在执行
            synchronized (resource) {
                //对包子的状态进行判断
                if (resource.status) {//如果是true则表示有包子，则生产者调用wait方法进入等待状态
                    try {
                        resource.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                //如果是false则表示没有包子，生产者生产包子-->生产者生产好了包子，就需要修改包子的状态为true，唤醒消费者吃包子
                //被唤醒之后执行，生产者生产包子
                //交替生产两种包子
                if (count % 2 == 0 ) {
                    //生产薄皮三鲜馅包子
                    resource.pi = "薄皮";
                    resource.xian = "三鲜馅";
                } else {
                    //生产冰皮牛肉馅包子
                    resource.pi = "冰皮";
                    resource.xian = "牛肉馅";
                }
                count++;
                System.out.println("生产者正在生产：" + resource.pi + resource.xian + "包子");
                //包子生产需要3s
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                //修改包子的状态为true
                resource.status = true;
                //唤醒消费者吃包子
                resource.notify();
                System.out.println("生产者已经生产好了" + resource.pi + resource.xian + "包子，消费者可以开始吃包子了");
            }
        }
    }
}
```

3.消费者类Consumer.java  

```java
package waitwake;

/*
消费者类：也是一个线程类，可以继承Thread；设置线程任务（消费资源）
对资源的状态进行判断，如果是false则表示没有资源，则消费者调用wait方法进入等待状态
如果是true则表示有资源，则消费者消费资源-->消费者消费完了资源，就需要修改资源的状态为false，唤醒生产者生产资源
*/
public class Consumer extends Thread{
    //在成员位置创建一个包子变量
    private Resource resource;

    //用带参数的构造方法，为这个包子变量赋值
    public Consumer(Resource resource) {
        this.resource = resource;
    }

    @Override
    public void run() {//吃包子
        while (true) {//消费者一直吃包子
            //必须使用同步技术保证两个线程只能有一个在执行
            synchronized (resource) {
                //对包子的状态进行判断
                if (!resource.status) {//如果是false则表示没有包子，则消费者调用wait方法进入等待状态
                    try {
                        resource.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                //如果是true则表示有包子，则消费者吃包子-->消费者吃完了包子，就需要修改包子的状态为false，唤醒生产者生产包子
                //被唤醒之后执行，消费者吃包子
                System.out.println("消费者正在吃：" + resource.pi + resource.xian + "包子");
                //修改包子的状态为false
                resource.status = false;
                //唤醒生产者生产包子
                resource.notify();
                System.out.println("消费者已经把" + resource.pi + resource.xian + "包子吃完了，生产者可以开始生产包子了");
                System.out.println("-------------------------------");
            }
        }
    }
}
```

4.测试类Test.java  

```java
package waitwake;

import java.util.concurrent.CompletionService;

/*
测试类：包含main方法，程序执行的入口
创建资源-->创建生产者线程并开启-->创建消费者线程并开启
*/
public class Test {
    public static void main(String[] args) {
        //创建包子
        Resource resource = new Resource();
        //创建生产者线程并开启
        new Producer(resource).start();
        //创建消费者线程并开启
        new Consumer(resource).start();
    }
}
```

5.执行结果  

```
生产者正在生产：薄皮三鲜馅包子
生产者已经生产好了薄皮三鲜馅包子，消费者可以开始吃包子了
消费者正在吃：薄皮三鲜馅包子

消费者已经把薄皮三鲜馅包子吃完了，生产者可以开始生产包子了
-------------------------------

生产者正在生产：冰皮牛肉馅包子
生产者已经生产好了冰皮牛肉馅包子，消费者可以开始吃包子了
消费者正在吃：冰皮牛肉馅包子

消费者已经把冰皮牛肉馅包子吃完了，生产者可以开始生产包子了
-------------------------------

生产者正在生产：薄皮三鲜馅包子
生产者已经生产好了薄皮三鲜馅包子，消费者可以开始吃包子了
消费者正在吃：薄皮三鲜馅包子
消费者已经把薄皮三鲜馅包子吃完了，生产者可以开始生产包子了
......
```